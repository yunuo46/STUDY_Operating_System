# 시스템 콜이 무엇인지 설명해 주세요.
운영체제는 다양한 서비스들을 수행하기 위해 하드웨어를 직접적으로 관리한다.

응용 프로그램은 운영체제가 제공하는 인터페이스를 통해서만 자원을 사용할 수 있다.

이러한 인터페이스를 시스템 콜이라고 한다.

## 우리가 사용하는 시스템 콜의 예시를 들어주세요.
리눅스 터미널에서 `in.text`에 있는 파일의 내용을 복사하여 `out.text`파일을 만드는 명령어

일반적으로 윈도우 운영체제라면 라면 마우스가, 리눅스라면 키보드가 사용자로부터 입력을 받는데 이때 I/O 시스템 콜을 사용

1. 'cp' 프로그램을 실행시키면 먼저 'in.txt' 파일이 현재 디렉터리에서 접근할 수 있는 파일인지를 검사하기 위해 시스템 콜을 호출
2. 만약 파일이 존재하지 않는 다면 에러를 발생시켜야 하고, 프로그램을 종료하는데 이때 시스템 콜이 사용
3. 만약 파일이 존재한다면, 복사한 파일을 저장하기 위해 'output.txt' 파일명이 있는지 검사
4. 이 때도 마찬가지로 이 파일 명이 존재하는지 존재하지 않는지 검사하기 위해 시스템 콜을 통해 확인
5. 그리고 만약 파일 명이 이미 존재한다면, 덮어 씌워야 할지 아니면, 이어서 붙여야 하는지 User에게 물어볼 수 있습니다. 만약 저장하고자 하는 파일 이름이 겹치지 않다면, 파일을 저장해야 하는데 이 때도 시스템 콜을 이용할 수 있음

## 시스템 콜이, 운영체제에서 어떤 과정으로 실행되는지 설명해 주세요.

1. 사용자 프로그램 실행 : 먼저, 사용자가 작성한 프로그램이 사용자 모드에서 실행됨
2. 시스템 콜 호출 : 프로그램이 운영체제의 특정기능을 사용해야 할 때, 그 기능을 호출하는데 사용되는 함수 또는 명령을 호출 → 시스템 콜
3. 사용자 모드에서 커널 모드로 전환 : 시스템 콜 호출이 발생하면 프로그램은 현재 실행 중인 사용자 모드에서 커널 모드로 전환(커널모드에서만 운영체제의 핵심 기능과 하드웨어 자원에 접근할 수 있기 때문)
4. 요청 분석 및 처리 : 커널은 내부적으로 시스템 콜 각각의 서비스 루틴에 대응되는 인덱스 테이블을 지니고 있고 시스템 콜이 호출되면 이에 대응되는 인덱스를 참조하여 서비스 루틴을 수행
5. 작업 수행 및 결과 반환 : 운영체제는 요청된 작업을 수행하고 결과를 메모리에 저장하거나 레지스터에 반환
6. 커널모드에서 사용자 모드로 전환 : 요청된 작업이 완료되면 운영체제는 다시 사용자 모드로 전환됨
7. 프로그램 실행재개 : 프로그램은 이제 시스템 콜 이후부터 다음 작업 계속 수행가능함


## 시스템 콜의 유형에 대해 설명해 주세요.
시스템 콜을 통해 커널에게 OS단의 처리를 할 수 있는 처리들을 하게 되는데 다음의 범주로 나눌 수 있다.

- 프로세스 제어 : `end`, `abort`, `create process`
- 파일 조작 : `create file` , `open` , `close` , `read`
- 장치 관리 : 마우스, 키보드 등의 디바이스 입출력
- 정보 유지 : 시스템 내부 데이터, 파일의 처리
- 통신 : 메시지 송수신 및 상태연결, 공유메모리 처리
- 정보 보호 : 파일 권한 처리

## 운영체제의 Dual Mode 에 대해 설명해 주세요.
운영체제는 운영체제를 사용자로부터 보호하기 위해 존재하는 기법으로 사용자와 운영체제 사이에서의 시스템 자원 공유 과정에서 사용자가 메모리 내의 주요한 운영체제의 지원을 망가뜨리지 않도록 보호하는 것이다.

Dual Mode는 다음 두 가지 모드로 나뉠 수 있다.

- 사용자 모드 : 사용자가 접근 가능
- 커널 모드 : 사용자가 접근 불가능

## 왜 유저모드와 커널모드를 구분해야 하나요?
일부 명령은 운영체제 내부에 나쁜 영향을 끼칠 수 있다. 이러한 명령들을 `priviledge instruction` 으로 지정하여 운영체제 자신과 유저에게 시스템 상의 보호를 제공할 수 있다.

특권 명령 : OS의 핵심 자원들을 직접 다룰 때 실행가능한 명령어로 다음이 존재한다.

- CPU 제어 및 보호 기법 : 타이머/인터럽트 관리
- 하드웨어 자원 관리 : I/O 관리
- 메모리 관리 (주소 공간 보호)


위 방식을 통해 `priviledge instruction` 이 커널 모드에서만 실행되도록 하여 사용자가 운영체제 내부에 문제를 발생시키지 않도록 처리한다.

실제로 사용자 모드에서 `priviledge instruction`을 사용하면 불법적인 명령으로 간주하여 `trap` 이라는 인터럽트를 걸게 된다.

## 서로 다른 시스템 콜을 어떻게 구분할 수 있을까요?
시스템 콜은 프로그램이 운영체제에게 접근하기 위해 운영체제에 요청을 보내 커널모드로 전환되어 자원에 접근을 요청하게 된다. 그 과정에서 여러 프로그램이 존재하고 시스템 콜을 발생시키는데 이러한 시스템 콜을 구분하기 위해서 시스템 콜의 번호를 레지스터에 저장하게 된다.

리눅스에서는 다음과 같은 방식으로 시스템 콜을 처리한다.

1. 레지스터를 이용하여 시스템 콜 번호(고유 번호) 및 매개 변수를 전달한다.
2. 매개 변수의 수가 5개 이상인 경우에는 os 메모리에 저장되며 stack의 형태로 매개변수들이 사용된다.

# 인터럽트가 무엇인지 설명해 주세요.
CPU가 현재 수행 중인 작업을 일시 중단하고 다른 특정 작업을 처리하도록 하는 신호이다. 주로 I/O 작업 처리 등이 존재하거나 시스템 콜에 의해 발생한다.

trap 또한 인터럽트의 한 종류이다.

## 인터럽트는 어떻게 처리하나요?
1. CPU에서 실행 중이던 프로그램의 상태 정보인 레지스터 값, 프로그램 카운터 등을 저장한다.
2. CPU에서 인터럽트 핸들러의 시작 주소가 있는 고정된 메모리 위치로 전환하여 실행한다. 이 때 mode bit는 커널모드로 변경된다.
3. 인터럽트 핸들러는 인터럽트의 원인을 파악한 후 필요한 처리를 수행한다.
4. 이후 처리가 완료되면 CPU에 저장했던 프로그램 상태를 복원한다.

## Polling 방식에 대해 설명해 주세요.
- CPU가 **주기적으로 I/O 장치의 상태를 직접 확인**하는 방식
- 장치가 준비되었는지, 데이터가 있는지를 계속 “물어보는” 구조
- **CPU가 능동적으로 검사** → 장치가 준비되지 않아도 계속 체크
- I/O가 느린 경우 CPU 자원을 낭비 (Busy waiting)
- 구현이 단순해서 초기 시스템, 임베디드 시스템에서 자주 사용됨

## HW / SW 인터럽트에 대해 설명해 주세요.
- HW 인터럽트 : 하드웨어 장치가 CPU에 서비스 요청을 알리기 위해 발생하는 물리적인 전기 신호로 주로 비동기적으로 발생합니다. 예를 들어, I/O 작업 완료, 하드웨어 오류 발생, 타이머 만료 등의 상황에서 발생합니다.

- SW 인터럽트 : 사용자 프로그램이 운영체제 서비스에 요청을 하거나 프로그램 실행 중 오류가 발생하여 CPU가 커널모드러 전환하면서 발생하는 인터럽트로 시스템 콜, 실행 오류 (잘못된 메모리 접근, 0으로 나누기 등) 이 존재한다.

## 동시에 두 개 이상의 인터럽트가 발생하면, 어떻게 처리해야 하나요?
프로세서와 시스템마다 인터럽트 처리 전략이 다르다. cpu는 인터럽트 우선순위를 기준으로 인터럽트를 처리한다. 이 때, 선점형 방식으로 동작한다.

1. 인터럽트 요청 중 가장 **높은 우선순위**를 가진 인터럽트를 식별한다.
2. 현재 작업중인 작업의 **상태를 저장**한다.
3. 우선 순위 순서대로 **인터럽트 서비스 루틴** or 인터럽트 핸들러가 실행된다
4. 인터럽트 처리 중 더 높은 우선순위의 인터럽트가 발생한다면 해당 인터럽트가 처리된다
5. 인터럽트 처리가 모두 완료되었다면 이전에 저장한 **작업을 복원**하여 작업을 재개한다.